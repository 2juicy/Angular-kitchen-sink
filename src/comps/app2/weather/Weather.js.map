{"version":3,"file":"Weather.js","sourceRoot":"","sources":["Weather.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;YAkDA;gBAgDI,iBAAoB,QAAiB,EAAU,cAA6B,EAAU,UAAqB;oBAAvF,aAAQ,GAAR,QAAQ,CAAS;oBAAU,mBAAc,GAAd,cAAc,CAAe;oBAAU,eAAU,GAAV,UAAU,CAAW;oBA9CnG,eAAU,GAAe,IAAI,mBAAW,EAAE,CAAC;oBAS5C,SAAI,GAAgC,EAAC,KAAK,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAC,CAAC;oBAsClE,IAAI,CAAC,kBAAkB,EAAE,CAAC;oBAC1B,IAAI,CAAC,UAAU,CAAC,UAAU,CAAC,cAAM,CAAC,QAAQ,EAAE,CAAC,UAAU,CAAC,CAAC,WAAW,CAAC,SAAS,CAAC,CAAC;gBACpF,CAAC;gBAED,iCAAe,GAAf;oBAAA,iBA8BC;oBA7BG,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;oBA0BlC,UAAU,CAAC;wBACP,KAAI,CAAC,QAAQ,CAAC,mBAAmB,CAAC,KAAI,CAAC,cAAc,CAAC,aAAa,EAAE,OAAO,EAAE,EAAE,CAAC,CAAA;oBACrF,CAAC,EAAE,IAAI,CAAC,CAAC;gBACb,CAAC;gBAED,oCAAkB,GAAlB;oBAAA,iBAaC;oBAZG,MAAM,CAAC,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,UAAU,CAAC,YAAY;yBAClD,YAAY,CAAC,GAAG,CAAC;yBACjB,oBAAoB,EAAE;yBACtB,MAAM,CAAC,UAAC,GAAU;wBACf,MAAM,CAAC,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC;oBAI1B,CAAC,CAAC,CAAC,SAAS,CAAC,UAAA,GAAG;wBACZ,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;wBACjB,MAAM,CAAC,KAAI,CAAC,cAAc,CAAC,MAAM,CAAI,GAAG,OAAI,CAAC,CAAA;oBACjD,CAAC,CAAC,CAAA;gBACV,CAAC;gBAlFD;oBAAC,gBAAS,CAAC,sBAAsB,CAAC;;+DAAA;gBAlDtC;oBAAC,gBAAS,CAAC;wBACP,QAAQ,EAAE,SAAS;wBACnB,SAAS,EAAE,CAAC,+BAAc,EAAE,+BAAc,CAAC;wBAC3C,eAAe,EAAE,8BAAuB,CAAC,MAAM;wBAC/C,MAAM,EAAE,CAAC,kCAAkC,CAAC;wBAC5C,QAAQ,EAAE,slCA0BX;qBACF,CAAC;;2BAAA;gBAqGF,cAAC;YAAD,CAAC,AAnGD,IAmGC;YAnGD,6BAmGC,CAAA","sourcesContent":["import {Component, ChangeDetectionStrategy, Renderer, ViewChild, ElementRef} from \"@angular/core\";\r\nimport {Consts} from \"../../../../src/Conts\";\r\nimport {IWeatherItem} from \"./IWeather\";\r\nimport {WeatherService} from \"./WeatherService\";\r\nimport {SortableHeader} from \"./SortableHeader\";\r\nimport {FormGroup, Validators, FormControl, FormBuilder} from \"@angular/forms\";\r\nimport {OrderBy} from \"../../../pipes/OrderBy\";\r\nimport {Observable} from \"rxjs/Observable\";\r\nimport 'rxjs/add/operator/distinctUntilChanged';\r\nimport 'rxjs/add/operator/switchMap';\r\nimport 'rxjs/add/operator/debounceTime';\r\nimport 'rxjs/add/operator/catch';\r\nimport 'rxjs/add/operator/do';\r\nimport 'rxjs/add/operator/distinctUntilChanged';\r\nimport {CommBroker} from \"../../../services/CommBroker\";\r\n\r\n@Component({\r\n    selector: 'Weather',\r\n    providers: [WeatherService, SortableHeader],\r\n    changeDetection: ChangeDetectionStrategy.OnPush,\r\n    styles: [`input {margin: 20px; width: 50%}`],\r\n    template: `\r\n    <small>I am a weather component</small>\r\n    <hr/>\r\n    <label style=\"padding-top: 5px; font-size: 1.4em\">Auto updated</label>\r\n    <SwitchComponent [label]=\"'My Switch'\"></SwitchComponent>\r\n    <input type=\"text\" #anotherWayToGetInput class=\"form-control\" placeholder=\"enter city or zip code\" [formControl]=\"zipControl\">\r\n    <table class=\"table\">\r\n      <thead>\r\n        <tr>\r\n          <th>day</th>\r\n          <th>icon</th>\r\n          <th sortableHeader=\"maxtempF\" [sort]=\"sort\">high</th>\r\n          <th sortableHeader=\"mintempF\" [sort]=\"sort\">low</th>\r\n        </tr>\r\n      </thead>\r\n      <tbody>\r\n      <!-- no need to subscribe to observable since async does this for us -->\r\n        <tr *ngFor=\"let item of weatherItems | async | OrderBy:sort.field:sort.desc\">\r\n          <td>{{ item.day }}</td>\r\n          <td><img src=\"{{ item.iconPath }}\" style=\"width: 40px; height: 40px\"/></td>\r\n          <td>{{ item.maxtempF }}</td>\r\n          <td>{{ item.mintempF }}</td>\r\n          <!-- <td [innerHtml]=\"item.day\"></td> -->\r\n        </tr>\r\n      </tbody>\r\n    </table>\r\n  `,\r\n})\r\n\r\nexport class Weather {\r\n    private weatherItems:Observable<IWeatherItem[]>;\r\n    private zipControl:FormControl = new FormControl();\r\n\r\n    // the real magic here is that the sort variable is being used in several places\r\n    // including here to set the pipe sorting, in the SortableHeader component to show and hide\r\n    // the header icons, as well as in SortableHeader to change the sort order on header clicks.\r\n    // So we pass the SAME sort var to all SortableHeader directives and all work with it\r\n    // in both displaying and the sorting mechanics\r\n    // we also use changeDetection: ChangeDetectionStrategy.OnPushObserve to make sure we use\r\n    // efficient rendering of the page only when the Observable is changes\r\n    public sort:{field:string, desc:boolean} = {field: null, desc: false};\r\n\r\n    // reference: http://angularjs.blogspot.com/2016/04/5-rookie-mistakes-to-avoid-with-angular.html\r\n    // this is a nice example of getting a reference to a native element (input) just by inserting\r\n    // an ng2 identifier to it (#anotherWayToGetInput)\r\n    @ViewChild('anotherWayToGetInput') myWeatherInput:ElementRef;\r\n\r\n    // if you need to access an element not in your view but instead through content projection\r\n    // you can use ContentChildren instead:\r\n    //@ContentChildren('myListInputs') myListInputs: QueryList<ElementRef>;\r\n\r\n\r\n    // Another great solution is to take advantage of the selector in the\r\n    // @Directive decorator. You simply define a directive that selects for <li> elements,\r\n    // then use IT (the directive) INSIDE your @ContentChildren query to filter all <li> elements down to only those\r\n    // that are content children of the component.\r\n    //\r\n    // ContentChildren and directive (recommended), user code:\r\n    // <my-list>\r\n    //      <li *ngFor=\"let item of items\"> {{item}} </li>\r\n    // </my-list>\r\n    //\r\n    // @Directive({ selector: 'li' })\r\n    // export class ListItem {}\r\n    //\r\n    // The component code:\r\n    // @Component({\r\n    //     selector: 'my-list'\r\n    // })\r\n    // export class MyList implements AfterContentInit {\r\n    //     @ContentChildren(ListItem) items: QueryList<ListItem>; // <--- MAGIC IS HERE, use directive to pull out list\r\n    //\r\n    //     ngAfterContentInit() {\r\n    //         // do something with list items\r\n    //     }\r\n    // }\r\n\r\n    constructor(private renderer:Renderer, private weatherService:WeatherService, private commBroker:CommBroker) {\r\n        this.listenWeatherInput();\r\n        this.commBroker.getService(Consts.Services().Properties).setPropView('Weather');\r\n    }\r\n\r\n    ngAfterViewInit() {\r\n        this.zipControl.setValue('91301');\r\n\r\n        /**\r\n        now we can access a native input element and set its focus in the proper way so we can\r\n        use this code in server side and other non-dom environments\r\n\r\n         examples include:\r\n         constructor( private renderer : Renderer, private element : ElementRef ) {\r\n                this.nativeElement = element.nativeElement;\r\n          }\r\n         let inputElement = this.renderer.createElement(this.nativeElement, “input”);\r\n         this.renderer.setElementAttribute(inputElement, “value”, “Hello from renderer”);\r\n         this.renderer.invokeElementMethod(inputElement, “focus”, []);\r\n         this.renderer.listenGlobal(\"body\", \"click\", () => console.log(\"Global event\"));\r\n\r\n         const pEleOne = this.renderer.createElement(this.nativeElement, \"p\");\r\n         const pEleTwo = this.renderer.createElement(this.nativeElement, \"p\");\r\n         this.renderer.createText(pEleOne, \"Element one\");\r\n         this.renderer.createText(pEleTwo, \"Element two\");\r\n         this.renderer.projectNodes(this.nativeElement, [pEleOne, pEleTwo]);\r\n\r\n         to see more options on render see:\r\n         https://medium.com/@NetanelBasal/angular-2-explore-the-renderer-service-e43ef673b26c#.1n66gf47q\r\n\r\n         **/\r\n\r\n        setTimeout(()=> {\r\n            this.renderer.invokeElementMethod(this.myWeatherInput.nativeElement, 'focus', [])\r\n        }, 1000);\r\n    }\r\n\r\n    listenWeatherInput() {\r\n        return this.weatherItems = this.zipControl.valueChanges\r\n            .debounceTime(400)\r\n            .distinctUntilChanged()\r\n            .filter((zip:string)=> {\r\n                return zip.length > 3;\r\n                // switchMap is really cool as it will both flatMap our Observables\r\n                // as well as it unsubscribes from all previous / pending calls to server and only\r\n                // listen to to newly created Observable\r\n            }).switchMap(zip => {\r\n                console.log(zip);\r\n                return this.weatherService.search(`${zip}/1`)\r\n            })\r\n    }\r\n}\r\n"]}