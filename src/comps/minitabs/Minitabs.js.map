{"version":3,"file":"Minitabs.js","sourceRoot":"","sources":["Minitabs.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;YAqCA;gBAAA;oBAsBY,gBAAW,GAAW,KAAK,CAAC;gBAgCxC,CAAC;gBAxCG,sBAAI,2BAAK;yBAAT,UAAU,OAAc;wBACpB,IAAI,CAAC,MAAM,GAAG,OAAO,CAAC;oBAC1B,CAAC;;;mBAAA;gBAED,qCAAkB,GAAlB;gBAEA,CAAC;gBAOD,2BAAQ,GAAR;oBACI,IAAI,CAAC,WAAW,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC;oBACrC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,UAAA,CAAC;wBACb,OAAO,CAAC,GAAG,CAAC,UAAU,GAAG,CAAC,CAAC,WAAW,CAAC,aAAa,CAAC,CAAC;oBAC1D,CAAC,CAAC,CAAC;gBACP,CAAC;gBAGD,qCAAkB,GAAlB;oBACI,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;oBAEvB,IAAI,UAAU,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,UAAC,GAAG,IAAG,OAAA,GAAG,CAAC,MAAM,EAAV,CAAU,CAAC,CAAC;oBAGrD,EAAE,CAAC,CAAC,UAAU,CAAC,MAAM,KAAK,CAAC,CAAC;wBACxB,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;gBACxC,CAAC;gBAED,4BAAS,GAAT,UAAU,GAAW,EAAE,KAAiB;oBAEpC,KAAK,GAAG,KAAK,CAAC,cAAc,EAAE,GAAG,IAAI,CAAC;oBACtC,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,OAAO,CAAC,UAAA,GAAG,IAAI,OAAA,GAAG,CAAC,MAAM,GAAG,KAAK,EAAlB,CAAkB,CAAC,CAAC;oBAGvD,GAAG,CAAC,MAAM,GAAG,IAAI,CAAC;gBACtB,CAAC;gBA3CD;oBAAC,mBAAY,CAAC,SAAS,CAAC;;wDAAA;gBAIxB;oBAAC,YAAK,CAAC,OAAO,CAAC;;;qDAAA;gBAUf;oBAAC,sBAAe,CAAC,iBAAO,CAAC;;sDAAA;gBAzC7B;oBAAC,gBAAS,CAAC;wBACP,QAAQ,EAAE,WAAW;wBACrB,MAAM,EAAE,CAAC,gFAIR,CAAC;wBACF,QAAQ,EAAE,sYASX;qBACF,CAAC;;4BAAA;gBAuDF,eAAC;YAAD,CAAC,AAtDD,IAsDC;YAtDD,+BAsDC,CAAA","sourcesContent":["import {Component, ContentChildren, QueryList, AfterContentInit, ViewChildren, Input} from '@angular/core';\r\nimport {Minitab} from './Minitab';\r\n\r\n/**\r\n *  Below I demonstrate dynamic class setup.\r\n *\r\n *  You can also do [class]=\"getClass()\"  and it will set a string of class or classes, but this will mess\r\n *  with any of the classes on the element if they are already set.\r\n *\r\n *  Often you will want to toggle a single class, which you can do by\r\n *  using a [class.className] syntax in the property.\r\n *\r\n *  and more examples for styles:\r\n *\r\n <!-- getColor() returns a valid color -->\r\n <h1 [style.color]=\"getColor()\">Title</h1>\r\n <h1 [style.line-height.em]=\"'2'\">Title</h1>\r\n\r\n **/\r\n@Component({\r\n    selector: 'mini-tabs',\r\n    styles: [`\r\n        .accent {\r\n            background-color: lightgray;\r\n        }\r\n    `],\r\n    template: `\r\n    <button [ngStyle]=\"_style\" (click)=\"isAccent($event)\">toggle a class style on/off</button>\r\n    <ul class=\"nav nav-tabs\">\r\n      <li let tabItem *ngFor=\"let tab of tabs\" (click)=\"selectTab(tab,$event)\" [class.active]=\"tab.active\"\r\n        [class.accent]=\"toggleClass\">\r\n        <a href=\"#\">{{tab.title}}</a>\r\n      </li>\r\n    </ul>\r\n    <ng-content></ng-content>\r\n  `\r\n})\r\nexport class Minitabs implements AfterContentInit {\r\n\r\n    _style:Object;\r\n\r\n    //As the name suggests, @ContentChild and @ContentChildren queries will return directives\r\n    //existing inside the <ng-content></ng-content> element of your view,\r\n    //whereas @ViewChild and @ViewChildren only look at elements\r\n    //that are on your view template directly (i.e. the shadow dom).\r\n    //here we are using the ViewChildren to grab all children via the tabItem index\r\n    @ViewChildren('tabItem')\r\n    myTabs:QueryList<any>;\r\n\r\n    // ability to style components by passing css\r\n    @Input('style')\r\n    set style(i_style:Object){\r\n        this._style = i_style;\r\n    }\r\n\r\n    ngAfterViewChecked() {\r\n        //console.log(this.myTabs);\r\n    }\r\n\r\n    private toggleClass:boolean = false;\r\n    @ContentChildren(Minitab)\r\n    tabs:QueryList<Minitab>;\r\n\r\n    // access native elements through the angular interface of ViewChildren\r\n    isAccent() {\r\n        this.toggleClass = !this.toggleClass;\r\n        this.myTabs.map(i=> {\r\n            console.log('my tabs ' + i._appElement.nativeElement);\r\n        });\r\n    }\r\n\r\n    // contentChildren are set\r\n    ngAfterContentInit() {\r\n        console.log(this.tabs);\r\n        // get all active tabs\r\n        let activeTabs = this.tabs.filter((tab)=>tab.active);\r\n\r\n        // if there is no active tab set, activate the first\r\n        if (activeTabs.length === 0)\r\n            this.selectTab(this.tabs.first);\r\n    }\r\n\r\n    selectTab(tab:Minitab, event?:MouseEvent) {\r\n        // deactivate all tabs\r\n        event ? event.preventDefault() : null;\r\n        this.tabs.toArray().forEach(tab => tab.active = false);\r\n\r\n        // activate the tab the user has clicked on.\r\n        tab.active = true;\r\n    }\r\n\r\n}"]}